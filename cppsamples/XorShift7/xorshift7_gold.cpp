//
// Copyright (c) 2011 QuantAlea GmbH.  All rights reserved.
//  

#include <algorithm>
#include <cmath>
#include <iomanip>
#include <iostream>

#include "xorshift7_gold.hpp"
#include "vector256.hpp"

namespace alea { namespace cuda { namespace math { namespace random {

    using namespace alea::cuda::math::f2;

	/*! 
		Initializes state.

		See http://www.iro.umontreal.ca/~lecuyer/myftp/papers/xorshift.pdf

		The generator state ins in x.
	*/
	void xorshift7Init (unsigned int x[8], unsigned int *init) {
		int j;
		for (j=0; j<8; j++) x[j] = init[j];
	}

	/*!
		Advances by one step and returns a number in [0,1).
		
		See http://www.iro.umontreal.ca/~lecuyer/myftp/papers/xorshift.pdf

		The generator state ins in x and will be updated.
	*/
	double xorshift7Next (unsigned int x[8]) {
		static int k = 0;
		unsigned int y, t;
		t = x[(k+7) & 0x7U];   t = t ^ (t<<13);   y = t ^ (t<<9);
		t = x[(k+4) & 0x7U];   y^= t ^ (t<<7);
		t = x[(k+3) & 0x7U];   y^= t ^ (t>>3);
		t = x[(k+1) & 0x7U];   y^= t ^ (t>>10);
		t = x[k];              t = t ^ (t>>7);    y^= t ^ (t<<24);
		x[k] = y;              k = (k+1) & 0x7U;
		return ((double) y * 2.32830643653869628906e-10 );
	}

    // The pi value, used for producing random numbers from normal
    // distribution.
    static const float PI = 3.14159265358979f;

    // The parameters of the linear congruential RNG, used to initialize
    // state of the xorshift7 RNG; these parametrs are as from "Numerical
    // Recipes" book (according to
    // http://en.wikipedia.org/wiki/Linear_congruential_generator).
    static const unsigned LCG_A = 1664525U;
    static const unsigned LCG_C = 1013904223U;

    Xorshift7Gold::Xorshift7Gold(void)
    {
        // Set all bits of RNG state to 0.
        std::fill(state_, state_ + 8, 0);
        index_ = 0;
    }

    Xorshift7Gold::Xorshift7Gold(const unsigned seed)
    {
        // Initialize RNG state using sequence of numbers generated by
        // linear congruential RNG with given seed, and set last state
        // number index to 0.
        state_[0] = seed;
        for (int i = 1; i < 8; ++i)
            state_[i] = LCG_A * state_[i - 1] + LCG_C;
        index_ = 0;
    }

    Xorshift7Gold::Xorshift7Gold(const unsigned* state)
    {
        // Initialize RNG state to given values, and set last state
        // number index to 0.
        std::copy(state, state + 8, state_);
        index_ = 0;
    }
    
	void printMat(const Matrix32 & m)
	{
		for (int i = 0; i < 32; ++i) {
			std::cout << std::hex << std::setw(8) << m.bits_[i]<< std::endl;
		}
	}

    Matrix256 Xorshift7Gold::getMatrix(void)
    {
        Matrix256 r;

        // Build xorshift7 RNG state update matrix, according to the RNG
        // definition as given by above mentioned paper.
        Matrix32 zero;
        Matrix32 identity = Matrix32::identity();
        for (int row = 0; row < 7; ++row)
            for (int col = 0; col < 8; ++col)
                r.set32x32Block(row, col, (row == col -1) ? identity : zero);
        r.set32x32Block(7, 0, (identity + Matrix32::left(24)) * ((identity + Matrix32::right(7))));
        r.set32x32Block(7, 1, identity + Matrix32::right(10));
        r.set32x32Block(7, 2, zero);
        r.set32x32Block(7, 3, identity + Matrix32::right(3));
        r.set32x32Block(7, 4, identity + Matrix32::left(7));
        r.set32x32Block(7, 5, zero);
        r.set32x32Block(7, 6, zero);
        r.set32x32Block(7, 7, (identity + Matrix32::left(9)) * ((identity + Matrix32::left(13))));
        
        return r;
    }

    void Xorshift7Gold::getState(unsigned* state)
    {
        // Copy numbers representing RNG state into given array.
        for (int i = 0; i < 8; ++i)
            state[i] = state_[(index_ + i) & 0x7];
    }

    unsigned Xorshift7Gold::getUnsignedUniform(void)
    {
        unsigned r;

        // Calculate next random number, and update xorshift7 RNG state,
        // again according to the RNG definition as given by above
        // mentioned paper.
        unsigned t;
        t = state_[(index_ + 7) & 0x7];
        t = t ^ (t << 13);
        r = t ^ (t << 9);
        t = state_[(index_ + 4) & 0x7];
        r ^= t ^ (t << 7);
        t = state_[(index_ + 3) & 0x7];
        r ^= t ^ (t >> 3);
        t = state_[(index_ + 1) & 0x7];
        r ^= t ^ (t >> 10);
        t = state_[index_];
        t = t ^ (t >> 7);
        r ^= t ^ (t << 24);
        state_[index_] = r;
        index_ = (index_ + 1) & 0x7;
    
        return r;
    }

    float Xorshift7Gold::getFloatUniform(void)
    {
        // Calculate next unsigned random number, and map it to the
        // [0,1] range, by dividing with largest unsigned integer.
        return getUnsignedUniform() / 4294967295.0f;
    }

    void Xorshift7Gold::getFloatNormal(float *value0, float *value1)
    {
        // Generate 2 uniformly distributed random numbers, and apply
        // Box-Muller transformation to produce 2 normally distributed
        // random numbers.  Return first among them, save the later for
        // the next call of this function.
        float r = std::sqrt(-2 * std::log(getFloatUniform()));
        float phi = 2 * PI * getFloatUniform();
        *value0 = r * std::cos(phi);
        *value1 = r * std::sin(phi);
    }

}}}}
